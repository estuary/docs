import:
  - rides.flow.yaml

collections:
  # Derive idle bikes by using two transformations of the "rides"
  # collection, both shuffled on bike_id.
  #
  # The first will read in real-time, and will store the last
  # ride timestamp in the bike's register.
  #
  # The second will read with a delay, and will check whether the
  # current register matches the end timestamp of the (delayed) ride.
  # If so, then the bike hasn't moved since this ride occurred,
  # and we publish an "idle bike" document into this collection.
  - name: examples/citi-bike/idle-bikes
    schema:
      type: object
      properties:
        bike_id: { type: integer }
        # Station at which the bike is idle.
        station: { $ref: ride.schema.yaml#/$defs/terminus }
      required: [bike_id, station]

    key: [/bike_id, /station/timestamp]

    derivation:
      register:
        # Store the most-recent ride timestamp for each bike_id,
        # or use null if the bike hasn't taken a ride before.
        schema: { type: [string, "null"] }
        initial: null

      transform:
        liveRides:
          source:
            name: examples/citi-bike/rides
          shuffle: [/bike_id]
          update:
            nodeJS: return [source.end.timestamp];

        delayedRides:
          source:
            name: examples/citi-bike/rides
          shuffle: [/bike_id]
          # Use a 2-day read delay. This is always relative to the timestamp
          # encoded within the document's UUID, assigned by Flow at the time the
          # document was ingested or derived.
          #
          # To see read delays in action within a testing context, where data is
          # replayed much more quickly, try using a smaller value (e.g., 2m).
          #
          # For (much) more detail on document UUIDs and timestamps, see:
          # https://gazette.readthedocs.io/en/latest/architecture-exactly-once.html?#message-uuids
          readDelay: "48h"
          publish:
            nodeJS: |
              if (register === source.end.timestamp) {
                return [{ bike_id: source.bike_id, station: source.end }];
              }
              return [];

tests:
  "Expect an idle bike is generated after the last ride in a sequence":
    - ingest:
        collection: examples/citi-bike/rides
        documents:
          - bike_id: &bike 17558
            begin:
              station: { id: 3276, name: "Marin Light Rail" }
              timestamp: "2020-09-01 09:21:12.3090"
            end: &station2
              station: { id: 3639, name: "Harborside" }
              timestamp: "2020-09-01 13:48:12.3830"
          - bike_id: *bike
            begin: *station2
            end: &station3
              station: { id: 3202, name: "Newport PATH" }
              timestamp: "2020-09-01 14:33:35.1020"
          - bike_id: *bike
            begin: *station3
            end: &station4
              station: { id: 3267, name: "Morris Canal" }
              timestamp: "2020-09-01 16:49:30.1610"
    - verify:
        collection: examples/citi-bike/idle-bikes
        # When running in a testing context, the testing framework advances
        # test time as needed, until all delayed collection reads have completed.
        # Expect we generate an idle bike for the last station arrived at.
        documents:
          - bike_id: *bike
            station: *station4
